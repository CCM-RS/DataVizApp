
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { w as writable, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_store, c as component_subscribe, a as validate_slots, l as createEventDispatcher, o as onMount, n as noop, e as element, b as space, m as create_component, f as attr_dev, g as add_location, h as insert_dev, p as mount_component, q as listen_dev, r as transition_in, x as transition_out, k as detach_dev, y as destroy_component, z as binding_callbacks, A as globals, B as metatags } from './main.js';

function loader (urls, test, callback) {
  let remaining = urls.length;

  function maybeCallback () {
    remaining = --remaining;
    if (remaining < 1) {
      callback();
    }
  }

  if (!test()) {
    urls.forEach(({ type, url, options = { async: true, defer: true }}) => {
      const isScript = type === 'script';
      const tag = document.createElement(isScript ? 'script': 'link');
      if (isScript) {
        tag.src = url;
        tag.async = options.async;
        tag.defer = options.defer;
      } else {
        tag.rel = 'stylesheet';
		    tag.href = url;
      }
      tag.onload = maybeCallback;
      document.body.appendChild(tag);
    });
  } else {
    callback();
  }
}

const mapsLoaded = writable(false);
const mapsLoading = writable(false);

/* node_modules/@anoram/leaflet-svelte/src/LoadSdk.svelte generated by Svelte v3.31.0 */

function create_fragment(ctx) {
	const block = {
		c: noop,
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $mapsLoaded;
	let $mapsLoading;
	validate_store(mapsLoaded, "mapsLoaded");
	component_subscribe($$self, mapsLoaded, $$value => $$invalidate(0, $mapsLoaded = $$value));
	validate_store(mapsLoading, "mapsLoading");
	component_subscribe($$self, mapsLoading, $$value => $$invalidate(3, $mapsLoading = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("LoadSdk", slots, []);
	const dispatch = createEventDispatcher();
	let L = {};
	let map = "";

	onMount(() => {
		if ($mapsLoaded) {
			dispatch("ready");
		}

		if (!$mapsLoading) {
			mapsLoading.set(true);

			loader(
				[
					{
						type: "style",
						url: `https://unpkg.com/leaflet@1.7.1/dist/leaflet.css`
					},
					{
						type: "script",
						url: `https://unpkg.com/leaflet@1.7.1/dist/leaflet.js`
					}
				],
				() => {
					return false;
				},
				() => {
					L = window.L;
					map = L.map;
					mapsLoaded.set(true);
					return true;
				}
			);
		}
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LoadSdk> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		loader,
		createEventDispatcher,
		onMount,
		mapsLoaded,
		mapsLoading,
		dispatch,
		L,
		map,
		$mapsLoaded,
		$mapsLoading
	});

	$$self.$inject_state = $$props => {
		if ("L" in $$props) L = $$props.L;
		if ("map" in $$props) map = $$props.map;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$mapsLoaded*/ 1) {
			 $mapsLoaded && dispatch("ready");
		}
	};

	return [$mapsLoaded];
}

class LoadSdk extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadSdk",
			options,
			id: create_fragment.name
		});
	}
}
LoadSdk.$compile = {"vars":[{"name":"loader","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"createEventDispatcher","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"onMount","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"mapsLoaded","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":false,"referenced_from_script":true},{"name":"mapsLoading","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":false,"referenced_from_script":true},{"name":"dispatch","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"L","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"map","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"$mapsLoaded","export_name":null,"injected":true,"module":false,"mutated":true,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":false},{"name":"$mapsLoading","export_name":null,"injected":true,"module":false,"mutated":true,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":false}]};

/* node_modules/@anoram/leaflet-svelte/src/Leaflet.svelte generated by Svelte v3.31.0 */

const { window: window_1 } = globals;
const file = "node_modules/@anoram/leaflet-svelte/src/Leaflet.svelte";

function create_fragment$1(ctx) {
	let div;
	let t;
	let loadsdk;
	let current;
	let mounted;
	let dispose;
	loadsdk = new LoadSdk({ $$inline: true });
	loadsdk.$on("ready", /*initialise*/ ctx[1]);

	const block = {
		c: function create() {
			div = element("div");
			t = space();
			create_component(loadsdk.$$.fragment);
			attr_dev(div, "class", "map svelte-1w5fv3e");
			attr_dev(div, "id", /*mapID*/ ctx[0]);
			add_location(div, file, 218, 0, 4923);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[7](div);
			insert_dev(target, t, anchor);
			mount_component(loadsdk, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window_1, "resize", /*resizeMap*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*mapID*/ 1) {
				attr_dev(div, "id", /*mapID*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadsdk.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadsdk.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[7](null);
			if (detaching) detach_dev(t);
			destroy_component(loadsdk, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Leaflet", slots, []);
	let L = {};
	let map = "";
	const dispatch = createEventDispatcher();
	let { options } = $$props;

	let { zoom = 13, maxZoom = 19, minZoom = 1, mapID = "map", attributionControl = true, center = [0, 0], markers, circles, recenter = false, scrollWheelZoom = true, tilelayers = [
		{
			url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
			attribution: "&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors"
		}
	], controls = {
		zoomControl: true,
		position: "topleft",
		scale: false
	} } = options;

	let icon;
	let markersArray = [];
	let circleArray = [];
	let bounds;

	let defaultIcon = {
		iconUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png",
		iconRetinaUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png",
		shadowUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png",
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [1, -34],
		shadowSize: [41, 41]
	};

	function initialise() {
		setTimeout(
			() => {
				L = window["L"];
				createMap();
				dispatch("ready");
			},
			1
		);
	}

	function makePopup(marker, options) {
		marker.bindPopup(options.text, {
			closeOnClick: false,
			autoClose: false,
			...options
		}).addTo(map);

		if (options.isOpen) {
			marker.openPopup();
		}
	}

	function makeTooltip(marker, options) {
		marker.bindTooltip(options.text, { ...options }).addTo(map);

		if (options.isOpen) {
			marker.openTooltip();
		}
	}

	let m = [];

	const addMarker = obj => {
		// console.log(obj);
		obj.markers.map((e, i) => {
			if (e.icon) {
				// console.log(e.icon)
				icon = L.icon(e.icon);
			}

			m[i] = new L.marker([e.lat, e.lng], { icon }).addTo(map);

			if (e.popup) {
				makePopup(m[i], e.popup);
			}

			if (e.tooltip) {
				makeTooltip(m[i], e.tooltip);
			}
		});
	};

	let added = false;

	const updateMarkers = obj => {
		if (!added) {
			addMarker(obj);
			added = true;
		}

		obj.markers.map((i, k) => {
			// console.log(i);
			m[k].setLatLng(i).update();

			m[k].addTo(map);
		});
	}; // map.panTo(arr[0])
	// console.log(m);

	const setZoom = (x = 5) => {
		map.setZoom(x);
	};

	function createMap() {
		map = L.map(mapID, {
			attributionControl,
			zoomControl: controls.zoomControl,
			minZoom,
			maxZoom
		}).setView(center, zoom);

		m = L.marker([0, 0]);

		if (tilelayers) {
			tilelayers.map(e => {
				L.tileLayer(e.url, { ...e }).addTo(map);
			});
		}

		if (!scrollWheelZoom) {
			map.scrollWheelZoom.disable();
		}

		let controlElement = L.control;

		if (!controls.zoomControl) {
			controlElement().remove();
		}

		if (controls.scale) {
			controlElement.scale({ position: controls.position }).addTo(map);
		}

		if (controls.zoomControl && controls.position) {
			map.removeControl(map.zoomControl);
			controlElement.zoom({ position: controls.position }).addTo(map);
		}

		if (markers) {
			markers.map(e => {
				markersArray.push([e.lat, e.lng]);

				if (e.icon) {
					icon = L.icon(e.icon);
				} else {
					icon = L.icon(defaultIcon);
				}

				let marker = new L.marker([e.lat, e.lng], { icon });

				if (e.popup) {
					makePopup(marker, e.popup);
				}

				if (e.tooltip) {
					makeTooltip(marker, e.tooltip);
				}

				marker.addTo(map);
			});
		}

		if (circles) {
			circles.map(e => {
				circleArray.push([e.lat, e.lng]);
				let circle = new L.circle([e.lat, e.lng], { ...e });

				if (e.popup) {
					makePopup(circle, e.popup);
				}

				if (e.tooltip) {
					makeTooltip(circle, e.tooltip);
				}

				circle.addTo(map);
			});
		}

		if (recenter) {
			if (markersArray.length == 1) {
				map.panTo(L.latLng(markersArray[0][0], markersArray[0][1]));
				map.setZoom(zoom);
			} else {
				bounds = new L.LatLngBounds(markersArray);
				map.fitBounds(bounds);
			}
		}
	}

	function resizeMap() {
		if (map) {
			map.invalidateSize();
		}
	}

	const writable_props = ["options"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Leaflet> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			mapID = $$value;
			$$invalidate(0, mapID);
		});
	}

	$$self.$$set = $$props => {
		if ("options" in $$props) $$invalidate(3, options = $$props.options);
	};

	$$self.$capture_state = () => ({
		LoadSdk,
		createEventDispatcher,
		L,
		map,
		dispatch,
		options,
		zoom,
		maxZoom,
		minZoom,
		mapID,
		attributionControl,
		center,
		markers,
		circles,
		recenter,
		scrollWheelZoom,
		tilelayers,
		controls,
		icon,
		markersArray,
		circleArray,
		bounds,
		defaultIcon,
		initialise,
		makePopup,
		makeTooltip,
		m,
		addMarker,
		added,
		updateMarkers,
		setZoom,
		createMap,
		resizeMap
	});

	$$self.$inject_state = $$props => {
		if ("L" in $$props) L = $$props.L;
		if ("map" in $$props) map = $$props.map;
		if ("options" in $$props) $$invalidate(3, options = $$props.options);
		if ("zoom" in $$props) zoom = $$props.zoom;
		if ("maxZoom" in $$props) maxZoom = $$props.maxZoom;
		if ("minZoom" in $$props) minZoom = $$props.minZoom;
		if ("mapID" in $$props) $$invalidate(0, mapID = $$props.mapID);
		if ("attributionControl" in $$props) attributionControl = $$props.attributionControl;
		if ("center" in $$props) center = $$props.center;
		if ("markers" in $$props) markers = $$props.markers;
		if ("circles" in $$props) circles = $$props.circles;
		if ("recenter" in $$props) recenter = $$props.recenter;
		if ("scrollWheelZoom" in $$props) scrollWheelZoom = $$props.scrollWheelZoom;
		if ("tilelayers" in $$props) tilelayers = $$props.tilelayers;
		if ("controls" in $$props) controls = $$props.controls;
		if ("icon" in $$props) icon = $$props.icon;
		if ("markersArray" in $$props) markersArray = $$props.markersArray;
		if ("circleArray" in $$props) circleArray = $$props.circleArray;
		if ("bounds" in $$props) bounds = $$props.bounds;
		if ("defaultIcon" in $$props) defaultIcon = $$props.defaultIcon;
		if ("m" in $$props) m = $$props.m;
		if ("added" in $$props) added = $$props.added;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		mapID,
		initialise,
		resizeMap,
		options,
		addMarker,
		updateMarkers,
		setZoom,
		div_binding
	];
}

class Leaflet extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				options: 3,
				addMarker: 4,
				updateMarkers: 5,
				setZoom: 6
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Leaflet",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*options*/ ctx[3] === undefined && !("options" in props)) {
			console.warn("<Leaflet> was created without expected prop 'options'");
		}
	}

	get options() {
		throw new Error("<Leaflet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<Leaflet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get addMarker() {
		return this.$$.ctx[4];
	}

	set addMarker(value) {
		throw new Error("<Leaflet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get updateMarkers() {
		return this.$$.ctx[5];
	}

	set updateMarkers(value) {
		throw new Error("<Leaflet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setZoom() {
		return this.$$.ctx[6];
	}

	set setZoom(value) {
		throw new Error("<Leaflet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}
Leaflet.$compile = {"vars":[{"name":"LoadSdk","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":false,"referenced_from_script":false},{"name":"createEventDispatcher","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"L","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"map","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"dispatch","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"options","export_name":"options","injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":true,"referenced_from_script":true},{"name":"zoom","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"maxZoom","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"minZoom","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"mapID","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":true,"writable":true,"referenced_from_script":true},{"name":"attributionControl","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"center","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"markers","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"circles","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"recenter","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"scrollWheelZoom","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"tilelayers","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"controls","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"icon","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"markersArray","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"circleArray","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"bounds","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"defaultIcon","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"initialise","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":false,"referenced_from_script":false},{"name":"makePopup","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"makeTooltip","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"m","export_name":null,"injected":false,"module":false,"mutated":true,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"addMarker","export_name":"addMarker","injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"added","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":true,"referenced":false,"writable":true,"referenced_from_script":true},{"name":"updateMarkers","export_name":"updateMarkers","injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":false},{"name":"setZoom","export_name":"setZoom","injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":false},{"name":"createMap","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"resizeMap","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":false,"referenced_from_script":false}]};

/* src/pages/index.svelte generated by Svelte v3.31.0 */
const file$1 = "src/pages/index.svelte";

function create_fragment$2(ctx) {
	let h1;
	let t1;
	let div;
	let map;
	let current;

	map = new Leaflet({
			props: { options: /*options*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			h1.textContent = "Projetos em fase avançada de licenciamento";
			t1 = space();
			div = element("div");
			create_component(map.$$.fragment);
			add_location(h1, file$1, 25, 0, 602);
			attr_dev(div, "class", "map svelte-1jnia5v");
			add_location(div, file$1, 26, 0, 654);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			mount_component(map, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(map.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(map.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			destroy_component(map);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pages", slots, []);
	metatags.title = "Comitê de Combate à Megamineração no Rio Grande do Sul (CCM/RS)";
	metatags.description = "O CCM/RS age pela garantia de realização de audiências públicas em todas as cidades envolvidas e pressionando para que a decisão final seja do povo gaúcho, através de plebiscitos.";

	let options = {
		center: [13, 80],
		markers: [{ lat: 13, lng: 80 }],
		mapID: "map"
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pages> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Map: Leaflet, metatags, options });

	$$self.$inject_state = $$props => {
		if ("options" in $$props) $$invalidate(0, options = $$props.options);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [options];
}

class Pages extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pages",
			options,
			id: create_fragment$2.name
		});
	}
}
Pages.$compile = {"vars":[{"name":"Map","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":false,"referenced_from_script":false},{"name":"metatags","export_name":null,"injected":false,"module":false,"mutated":true,"reassigned":false,"referenced":false,"writable":false,"referenced_from_script":true},{"name":"options","export_name":null,"injected":false,"module":false,"mutated":false,"reassigned":false,"referenced":true,"writable":true,"referenced_from_script":false}]};

export default Pages;
//# sourceMappingURL=index.js.map
